cat(va,' ',Va)
print(va,' ',Va)
a<-10
b<-20
(c<-a+b) #
va <- 1   # 변수의 값 할당
va <- 2
va = 3    # 주로 함수 내에서 = 사용
4 -> Va   # 대 소문자 구분분
cat(va,' ',Va)
print(va) # print는 하나씩
a<-10
b<-20
(c<-a+b) # print안쓰고 ()써도됨
a.b <- 3
print(a.b)
# 데이터 유형
kbs <- 9
typeof(kbs)
kbs <- 9.5
typeof(kbs)
mode(kbs)
mbc <- as.integer(kbs)
typeof(mbc)
mbc
typeof(mbc)
mbc <- 11L # 실수가 정수화
typeof(mbc)
ss <- "홍길동"
typeof(ss)
mode(ss)
bb <- TRUE
typeof(bb)
mode(bb)
cc <- 5.3 - 3i
typeof(cc)
mode(cc)
# NA : 결측 데이터(값이 입력되지 않은 상태)
dd <- NA
typeof(dd)
mode(dd)
is.na(dd)
sum(2,3) # 합을 구하는 내장함수
sum(2,3,NA)
sum(2,3,NA, na.rm = TRUE)
va <- 1   # 변수의 값 할당
va <- 2
(c<-a+b) # print안쓰고 ()써도됨
a.b <- 3
print(a.b)
.libPaths()
.libPaths("C:\mywork")
.libPaths(C:\mywork)
.libPaths("C:\mywork)
.libPaths("C:\mywork)
# 데이터 유형
kbs <- 9 # 숫자형 (numeric : double)
typeof(kbs)
kbs <- 9.5 # 숫자형 (numeric : double)
typeof(kbs)
mode(kbs)
sum(2,3,NA, na.rm = TRUE) # na.rm = TRUE를 사용하여 NA를 없애고 연산
# 데이터 유형
kbs <- 9 # 숫자형 (numeric : double)
typeof(kbs)
kbs <- 9.5 # 숫자형 (numeric : double)
typeof(kbs)
mode(kbs)
class(kbs)
typeof(NULL)
typeof(NULL) # 값으로 인식 X
sum(2,3,NULL)
length(NULL)
typeof(NA) # 값으로 인식 X
length(NA) # 0
sum(2,3,NA)
typeof(NAN) # 값으로 인식 O
length(NAN) # 1
sum(2,3,NAN) # NA는 값으로 인식하여 계산 불가
typeof(NaN) # 값으로 인식 O
length(NaN) # 1
sum(2,3,NaN) # NA는 값으로 인식하여 계산 불가
print(Inf)
0 / 0
Inf
0 / 0
Inf + - Inf
0 * Inf
0 * Inf
kbs <- c('second','first','third','first')
kbs
typeof(kbs)
mbc <- as.factor(kbs)
mbc
typeof(mbc)
typeof(mbc)
mbc <- as.factor(kbs)
mbc
typeof(mbc)
typeof(mbc)
summary(mbc)
summary(mbc)
mbc <- as.factor(kbs)
mbc
typeof(mbc)
summary(mbc)
f <- function(){
return ('good')
}
f()
typeof(f)
#--------------------
ls()
rm(bb)
ls()
rm(list=ls())
ls()
gc()
f()
typeof(f) #closure
#-- package(데이터 + 기능(함수) + 알고리즘 <== 얘네들의 묶음) --------------
# 라이브러리가 패키지 단위로 지원
available.packages()
dim(available.packages())
installed.packages()
install.packages("plyr") #패키지 설치
install.packages("plyr") #패키지 설치
library("plyr") # 라이브러리 로딩
search()
detach('plyt')
detach('plyr')
ls("package:plyr")
detach("plyr")
ls("package:plyr") # plyr 패키지가 제공하고 있는 내용
data(package="plyr")
baseball
# 도움말
help("mean")
x <- c(0:10, 50)
xm <- mean(x)
c(xm, mean(x, trim = 0.10))
xm <- mean(x)
x <- c(0:10, 50) #
x
?mean
y <- 2022
y
y[0]
y[0]
y[1]
y[2]
is.vector(y)
mode(y)
y[0] # numeric(0)
y[1] # 2022 인덱스 1 부터 시작
y[2] # NA
is.vector(y) # TRUE
mode(y) # "numeric"
class(y)
y <- as.integer(y)
class(y)
seq(1,5)
1:5
seq(1,10,2)
seq(1,10,length.out = 4)
rep(1:3, 3)
rep(1:3, each=3)
?rep
v <- c(10,20,30,-5,-10)
v
v <- c(10,20,30,-5,-10, 'a')
v #  10  20  30  -5 -10
v <- c(10,20,30,-5,-10, 'a',True)
v #  10  20  30  -5 -10
v <- c(10,20,30,-5,-10, 'a',True)
v <- c(10,20,30,-5,-10, 'a',TRUE)
v #  10  20  30  -5 -10
v <- c(10,20,30,-5,-10, 'a',TRUE,F,T)
v #  10  20  30  -5 -10
v <- c(10,20,30,-5,-10)
v
v <- c(1,5,6:10,12)
v
age <- c(10,20,30)
names(age)
names(age) <- c("상인","정환","준")
age
age["상인"]
age[1]
age["상인"]
age <- c(age,40)
age
age
age[10] <- 50
age
age <- append(age, 60, after = 6)
age
age
age <- NULL
age
rm(age)
age
name(age) <- c("상인","정환","준") # 벡터의 칼럼명 지정
age <- c(10,20,30)
name(age) <- c("상인","정환","준") # 벡터의 칼럼명 지정
names(age) <- c("상인","정환","준") # 벡터의 칼럼명 지정
age <- c(10,20,30)
names(age) <- c("상인","정환","준") # 벡터의 칼럼명 지정
age[1]
age["상인"]
# 인덱싱, 슬라이싱
v <- c(13, -5, 20:23,12,-2:3)
v
v[1]
v[c(2,4,5)]
v[1:5]
v[-1]
v[-c(2,4,5)]
a <- 1:30
a
a %% 3
a <- 1:10
a
a %% 3 #  1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0
a+5
a^2
a**2
sqrt(a)
sqrt(a)**2
a <- 1:4
b <- 4:6
a
b
a + b
a <- 1:3
b <- 4:6
a
b
a + b
a * b
union(a,b) # 합집합합
a + b # 5 7 9
a * b
a[4] <- 2
a
b
b
union(a,b) # 합집합(중복 X)
c(a,b) # 벡터 결합 (중복 O)
setdiff(a,b)
b[4] <- 2
b
intersect(a,b)
a <- 1:3
b <- 4:6
a
b
a + b # 5 7 9
a * b # 4 10 18
a[4] <- 2
a
b
union(a,b) # 합집합(중복 X) 1 2 3 4 5 6
c(a,b) # 벡터 결합 (중복 O) 1 2 3 2 4 5 6
setdiff(a,b) # 차집합 1 2 3
b[4] <- 2
b # 4 5 6 2
intersect(a,b) # 교집합 2
# -------Matrix(행렬 구조, 2차원 배열)----------------
a <- 1:8
dim(a)
dim(a) < c(2,4)
dim(a) <- c(2,4)
a
#      [,1] [,2] [,3] [,4]
# [1,]    1    3    5    7
# [2,]    2    4    6    8
class(a)
typeof(a)
m <- matrix(c(1:5))
m
# [,1]
# [1,]    1
# [2,]    2
# [3,]    3
# [4,]    4
# [5,]    5
dim(m)
# [,1]
# [1,]    1
# [2,]    2
# [3,]    3
# [4,]    4
# [5,]    5
dim(ㅡㅡ)
# [,1]
# [1,]    1
# [2,]    2
# [3,]    3
# [4,]    4
# [5,]    5
dim(m)
m <- matrix(1:9)
m
dim(m) # 5 1, 매트릭스의 차원 5행 1열
m <- matrix(1:9, nrow = 3)
m
dim(m)
m <- matrix(1:9, nrow = 3, byrow = T) # 행의 개수 지정
m
#       [,1] [,2] [,3]
# [1,]    1    2    3
# [2,]    4    5    6
# [3,]    7    8    9
dim(m)
m
m[1]
m[1,]
m[1,] # 1 2 3, 1행이 나옴
m[,1]
m[, -1]
#       [,1] [,2]
# [1,]    2    3
# [2,]    5    6
# [3,]    8    9
m[-1, -1]
#       [,1] [,2]
# [1,]    5    6
# [2,]    8    9
m[1,c(1,3)]
rownames(m) <- c('r1','r2','r3')
colnames(m) <- c('하나','둘','셋')
m
#     하나 둘 셋
# r1    1  2  3
# r2    4  5  6
# r3    7  8  9
m['r1',]
# 하나   둘   셋
#   1    2    3
dim(m)
length(m)
NROW(m)
nrow(m)
# 연산
a < matrix(c(1,2,3,4))
# 연산
a < matrix(c(1,2,3,4),nrow=2,ncol=2)
b = matrix(5:8 , 2, 2)
b
# 연산
a < matrix(c(1,2,3,4),nrow=2,ncol=2)
# 연산
a <- matrix(c(1,2,3,4),nrow=2,ncol=2)
a
b <- matrix(5:8 , 2, 2)
b
a + b
a - b
a * b
a %*% b
a
diag(a)
diag(3)
# 행 또는 열 결합
x <- c(5,40,50:52)
x
y <- c(30,5,6:8)
y
mr <- rbind(x,y)
mr
apply
apply
apply
apply
# apply() : 함수를 실행하는 함수
?apply
x <- matrix((1:9,nrow=3))
x <- matrix(1:9,nrow=3)
x
#       [,1] [,2] [,3]
# [1,]    1    4    7
# [2,]    2    5    8
# [3,]    3    6    9
apply(x,1,max)
apply(x,2,max) # 열열기준 7 8 9
func <- function(x){
x + c(1, 5, 10)
}
apply(x, 1, func)
iris
?iris
dim(iris)
iris.head(3)
head(iris)
head(iris,3)
data()
tail(iris,3)
apply(iris([, 1:4],2,mean))
apply(iris[, 1:4],2,mean)
apply(iris[, 1:4],mean)
lapply(iris[,1:4], mean)
apply(iris[, 1:4],mean)
apply(iris[, 1:4],2, mean)
lapply(iris[,1:4], mean)
sapply(iris[,1:4], mean)
#Array : 다차원 배열
d <- c(1:12)
arr1 <- base::array(d) # base package에 array , base 생략 가능
arr1
dim(arr1)
length(arr1)
is.array(arr1)
arr2 <- array(1:12, dim = c(6,2))
arr2
dim(arr2)
arr3 <- array(1:12, dim = c(3,2,2)) # 3행 2열 2면 구조의 배열
arr3
dim(arr3)
arr3[,,1] # 1면만 추출
arr3[,1,1] # 1면 1열만 추출
arr3[1,1] # 1면 1행만 추출
arr3[1,,1] # 1면 1행만 추출
arr3[1,1,1] # 1면 1행 1열만 추출출
# List :서로 다른 타입의 데이터를 기억할 수 있다. 키, 값 형태의 테이터를 담는 연관배열
num <- list(c(1:5),c(6:10),c('a','b','c'))
num
num[1]
cat(num[1],class(num[1]))
cat(num[1],class(num))
class(num[1])
class(num[[1]])
num[[1]]
class(num[[1]])
num[[1]][2]
num$[1
num$1
num2 <- list(x = 1:5)
num2 <- list(x = 1:5, y=6:10)
num2
num2$ㅌㅌ
num2$x
# 참고
a <- 1
tracemem(a)
untracemem(a)
untracemem(a)
# vector로 data.frame 객체 생성
no <- c(1,2,3)
name <- c("hong","lee","kim")
pay <- c(200,250,300)
df <- data.frame(no,name,pay)
df
#   no name pay
# 1  1 hong 200
# 2  2  lee 250
# 3  3  kim 300
type(df)
#   no name pay
# 1  1 hong 200
# 2  2  lee 250
# 3  3  kim 300
typeof(df)
class(df)
is(df)
df <- data.frame(bunho=no,irum=name,imkum=pay)
df
df <- data.frame(irum=c('james','oscar','tom'),nai=c(33,44,22))
df
df <- data.frame(irum=c('james','oscar','tom'),nai=c(33,44,22), row.names = c("one","two","three"))
df
nrow(df)
ncol(df)
str(df)
df%irum
df$irum
df%nai
df$nai
summary(df)
head(df)
head(df,n=2)
tail(df,n=2)
names(df)
# matrix로 data.frame 객체 생성
m<-matrix(c(1,"hong",150,2,'lee',250,3,'kim',300))
m
# matrix로 data.frame 객체 생성
m<-matrix(c(1,"hong",150,2,'lee',250,3,'kim',300),3, by=T)
m
#       [,1] [,2]   [,3]
# [1,] "1"  "hong" "150"
# [2,] "2"  "lee"  "250"
# [3,] "3"  "kim"  "300"
mdf <- data.frame(m)
mdf
source("C:/mywork/rsou/pro1/ex3dataFrame.R", encoding = 'UTF-8')
#   X1   X2  X3
# 1  1 hong 150
# 2  2  lee 250
# 3  3  kim 300
class(mdf)
m <- matrix(1:6, nrow = 3)
m
mdf <- data.frame(m)
mdf
colnames(mdf) <- c("c1","c2")
mdf
mdf$c1
mdf['c1']
mdf[,2] # 모든
mdf[1,2]
mdf[1:2,1:2]
